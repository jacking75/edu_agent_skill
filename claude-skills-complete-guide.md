# Claude Skills 완전 정리

[출처](https://qiita.com/nogataka/items/cace9602e4eaea995cc9 )  
  
## **개요**
2026년 1월, Anthropic이 *"The Complete Guide to Building Skills for Claude"* (32페이지 PDF)를 공개했다. **스킬(Skill)** 이란 Claude에게 특정 태스크를 일관되게 실행시키기 위한 구조로, Markdown 파일을 폴더에 넣는 것만으로 Claude의 동작 방식을 바꿀 수 있는 **재사용 가능한 프롬프트**다.

---

## **스킬의 구조**
스킬의 실체는 단순하다. 필수 파일은 `SKILL.md` 하나뿐이며, 나머지는 선택 사항이다.

```
your-skill-name/
├── SKILL.md          # 필수. 지시사항 본체
├── scripts/          # 선택. 실행 가능한 코드
├── references/       # 선택. 보충 문서
└── assets/           # 선택. 템플릿 등
```

---

## **3가지 설계 원칙**

**1. 프로그레시브 디스클로저 (단계적 개시):**

스킬의 읽기 로딩은 3단계로 제어된다.

| 레벨 | 로딩 대상 | 타이밍 |
|------|-----------|--------|
| 1단계 | YAML 프론트매터 | 항상 로딩 |
| 2단계 | SKILL.md 본문 | 스킬 발동 시 |
| 3단계 | `references/` 내 파일 | Claude가 필요하다고 판단 시 |

프론트매터는 **항상 컨텍스트 윈도우에 존재**하기 때문에, 스킬을 20개 활성화해도 실용적이다. 전체 스킬의 프론트매터만 상주하고, 실제 지시는 발동 시에만 전개되어 컨텍스트 절약과 전문성을 동시에 달성한다. 따라서 프론트매터가 너무 크면 다른 스킬이나 대화를 압박하므로, 프론트매터는 "언제 사용할지"의 판정 정보만 담아야 한다.

**2. 컴포저빌리티 (조합 가능성):**

Claude는 여러 스킬을 동시에 로딩할 수 있다. 가이드는 "스킬이 유일한 기능이라고 가정하지 말라"고 명시한다. 예를 들어 `qiita-writing` + `frontend-design`을 조합하면 Qiita 기사에 인터랙티브 데모를 삽입할 수 있고, `sentry-code-review` + `linear-tasks` 조합으로 버그를 감지해 태스크까지 자동 생성할 수 있다.

**3. 포터빌리티 (이식성):**

스킬은 Claude.ai, Claude Code, API 모든 환경에서 동일하게 동작한다. 한 번 만들면 어느 환경에서도 그대로 사용 가능하다.

---

## **description이 9할: 스킬 발동 원리**
가이드에서 가장 중요하게 다루는 부분이 바로 YAML 프론트매터의 `description` 필드다. Claude는 사용자 요청과 활성화된 스킬의 `description`을 대조해 관련도가 높은 스킬을 자동으로 로딩한다.

```yaml
---
name: your-skill-name
description: 무엇을 하는가. 사용자가 [특정 문구]를 요청할 때 사용.
---
```

**좋은 description vs 나쁜 description:**

```yaml
# 나쁜 예: 너무 모호해서 모든 것에 매칭될 수 있다
description: 프로젝트를 지원한다.

# 좋은 예: 구체적인 트리거 문구를 포함한다
description: 스프린트 계획, 태스크 생성, 상태 추적을 포함한
  Linear 프로젝트 워크플로우를 관리. 사용자가 "스프린트",
  "Linear 태스크", "프로젝트 계획"에 언급하거나
  "티켓 생성"을 요청할 때 사용.
```

description의 구성 요소는 `[무엇을 하는가]` + `[언제 사용하는가]` + `[주요 기능]` 3가지다. 스킬이 트리거되지 않을 때는 본문을 아무리 수정해도 소용없다. 문제는 거의 확실히 `description`에 있다. 디버그 방법은 Claude에게 "[\[스킬명\]] 스킬은 언제 사용하나요?"라고 질문하는 것이다.

---

## **MCP와 스킬의 관계: 주방과 레시피**
가이드의 핵심 비유가 **"주방과 레시피"** 다.

- **MCP** = 프로 주방 (툴, 재료, 설비 접근)
- **스킬** = 레시피 (가치 있는 것을 만드는 단계별 지시)

|  | MCP만 있을 때 | MCP + 스킬 |
|--|--------------|------------|
| 첫 경험 | "뭘 해야 할지 모르겠다" | 워크플로우가 자동 안내 |
| 결과 안정성 | 사용자 프롬프트에 따라 다름 | 일관된 품질 |
| 지원 부담 | 사용법 질문 다발 | 학습 곡선이 낮음 |

MCP를 제공하는 서비스 입장에서 스킬은 "사용법 문서를 쓰는" 게 아니라 **"사용법 자체를 Claude에 심는"** 행위다.

---

## **3가지 스킬 카테고리**

**카테고리 1 — 문서 & 에셋 생성:**

외부 툴 없이 Claude 내장 기능만으로 완결되는 스킬이다. 프론트엔드 디자인, 문서 생성, 프레젠테이션 작성 등이 해당된다. 스타일 가이드나 템플릿을 내장해 일관된 출력 품질을 보장한다. **처음 시작할 때 가장 권장하는 카테고리다.**

**카테고리 2 — 워크플로우 자동화:**

멀티 스텝 프로세스를 일관된 방법론으로 실행하는 스킬이다. 스킬 자체를 만드는 스킬(`skill-creator`), 스프린트 계획 등이 해당된다. 유효성 검사 게이트와 개선 루프를 포함해 절차를 표준화한다.

**카테고리 3 — MCP 강화:**

MCP 서버가 제공하는 툴 접근에 워크플로우 지식을 더하는 스킬이다. 예를 들어 Sentry 에러 데이터를 활용해 PR 버그를 자동 수정하는 스킬 등이 있다. 여러 MCP 호출을 올바른 순서로 연계하고 도메인 전문 지식을 내장한다.

---

## **5가지 실전 패턴**

**패턴 1 — 시퀀셜 워크플로우:** 순서가 있고 이전 단계 결과를 다음 단계에서 사용하는 경우에 활용한다. 예: 고객 온보딩(계정 생성 → 결제 설정 → 구독 → 환영 이메일). 각 단계에 유효성 검사를 넣고, 실패 시 롤백 지시를 명기하는 것이 핵심이다.

**패턴 2 — 멀티 MCP 코디네이션:** 하나의 워크플로우가 여러 서비스에 걸쳐 있는 경우에 활용한다. 예: 디자인 핸드오프(Figma → Drive → Linear → Slack). 페이즈를 명확히 나누고 페이즈 간 데이터 전달 의존 관계를 명시한다.

**패턴 3 — 반복적 개선:** 한 번에 완벽한 출력이 어렵고 이터레이션으로 품질을 높이는 경우에 활용한다. 예: 리포트 생성(드래프트 → 품질 체크 → 개선 → 재체크 → 최종화). `scripts/`에 유효성 검사 스크립트를 준비해 프로그래밍적으로 체크하는 것이 효과적이다.

**패턴 4 — 컨텍스트 대응 툴 선택:** 같은 목적이라도 상황에 따라 최적 수단이 달라지는 경우에 활용한다. 예: 파일 저장(대형 파일 → 클라우드 스토리지, 코드 → GitHub, 임시 파일 → 로컬). 판단 트리를 명시하고 왜 그 선택을 했는지 사용자에게 설명하도록 설계한다.

**패턴 5 — 도메인 고유 인텔리전스:** 툴 접근 이상의 전문 지식이 가치를 갖는 경우에 활용한다. 예: 컴플라이언스 포함 결제 처리(제재 리스트 확인 → 관할 구역 검증 → 리스크 평가 → 처리 → 감사 기록). 도메인 규칙을 스킬에 내장해 "올바른 순서로 올바른 판단을 한 후 툴을 호출"하는 동작을 구현한다.

---

## **자주 빠지는 함정과 대처법**

**스킬이 트리거되지 않는 경우:** 원인은 거의 `description`에 있다. `description`이 너무 일반적이진 않은지, 사용자가 실제로 말할 법한 문구를 포함하는지, 관련 파일 타입에 언급하는지 확인한다.

**스킬이 너무 자주 트리거되는 경우:** `description`에 네거티브 트리거("~에는 사용하지 않는다")를 추가한다.

```yaml
description: CSV 파일의 고급 데이터 분석. 통계 모델링, 회귀, 클러스터링에 사용.
  단순한 데이터 탐색에는 사용하지 않음 (data-viz 스킬 사용).
```

**지시가 지켜지지 않는 경우:** 지시가 너무 장황하다면 간결하게 목록화하고, 중요한 지시를 앞부분에 배치하고, 애매한 표현 대신 구체적인 조건을 열거한다. 가이드의 고급 기법으로 **중요한 유효성 검사는 스크립트로 만드는** 방법을 권장한다. "언어의 해석은 불확실하지만 코드는 결정론적"이기 때문이다.

**컨텍스트가 너무 커서 느린 경우:** SKILL.md 본문을 5,000단어 이하로 유지하고, 세부 문서는 `references/`로 분리하고, 20~50개 이상의 스킬을 동시에 활성화하지 않는지 확인한다.

---

## **테스트 방법**

| 테스트 종류 | 목적 | 방법 |
|------------|------|------|
| 트리거 테스트 | 적절한 타이밍에 발동하는가 | 10~20개 테스트 쿼리를 실행해 발동률 확인 |
| 기능 테스트 | 올바른 출력을 생성하는가 | 같은 태스크를 3~5회 실행해 일관성 확인 |
| 퍼포먼스 비교 | 스킬 적용으로 개선됐는가 | 스킬 미적용과 비교 (대화 횟수, 에러율, 토큰 소비량) |

가이드 예시에서 스킬 없이 15회 대화·API 에러 3회·12,000 토큰이 필요했던 태스크가, 스킬 적용 후 확인 2회·에러 0회·6,000 토큰으로 개선됐다. 또한 **"먼저 어려운 태스크 1개로 이터레이션하고, 성공한 접근법을 스킬로 추출"** 하는 방식을 권장한다. 처음부터 완벽한 스킬을 설계하려 하지 말고, 실제 대화에서 성공 패턴을 찾은 후 스킬화하는 편이 빠르다.

---

## **배포 방법**
현재 주요 배포 방법은 두 가지다.

- **Claude.ai** → 설정 > 기능 > 스킬 에서 ZIP으로 업로드
- **Claude Code** → `~/.claude/skills/` 폴더에 배치

조직용으로는 관리자가 워크스페이스 전체에 스킬을 배포하는 기능도 제공된다. API에서는 `/v1/skills` 엔드포인트와 Messages API의 `container.skills` 파라미터로 프로그래밍적 제어가 가능하다. 스킬은 MCP와 마찬가지로 특정 플랫폼에 종속되지 않는 **오픈 스탠다드**로 설계되어 있다.

---

## **핵심 요약**
스킬은 단순한 "프롬프트 저장"이 아니다. **단계적 개시**로 컨텍스트를 효율적으로 사용하고, **description**으로 발동 타이밍을 제어하고, **references/**로 필요할 때만 지식을 전개하고, **scripts/**로 유효성 검사를 결정론적으로 수행한다. 이 설계 덕분에 스킬은 "매번 같은 것을 설명하는 수고를 줄이는" 것을 넘어, **Claude의 판단과 출력 품질을 구조적으로 끌어올리는 메커니즘**으로 기능한다.  